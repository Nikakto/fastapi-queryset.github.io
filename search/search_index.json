{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Querysets","text":"<p>Documentation: https://fastapi.tiangolo.com</p> <p>Source Code: https://github.com/Nikakto/fastapi-querysets</p>"},{"location":"#why-to-use","title":"Why to use?","text":"<p>While you are developing FastAPI applications you are using databases with ORM. Most of the endpoints are view of database tables and require restrict queryset by filtering, pagination, ordering. This project is generic and reusable way to create restricted querysets for your endpoints.</p>"},{"location":"#supported-orm","title":"Supported ORM","text":"<ul> <li>Tortoise ORM</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>python &gt;=3.8,&lt;4.0</li> <li>fastAPI &gt;= 0.7.0</li> <li>tortoise-orm &gt;= 0.18.1</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fastapi-querysets\n</code></pre>"},{"location":"example/","title":"Example","text":""},{"location":"example/#tortoise-model","title":"Tortoise model","text":"<p>Let\u2019s start with our model</p> <pre><code># models/tortoise.py\n\nimport datetime\nfrom typing import Optional\n\nfrom tortoise import Model\nfrom tortoise import fields\n\n\nclass Task(Model):\n    id: int = fields.IntField(pk=True)\n    approved: Optional[bool] = fields.BooleanField(default=False, null=True)\n    code: str = fields.CharField(max_length=6)\n    created_at: datetime.datetime = fields.DatetimeField(default=datetime.datetime.now)\n</code></pre>"},{"location":"example/#pydantic-model","title":"Pydantic model","text":"<p>Create database representation model</p> <pre><code># models/pydantic.py\n\nfrom tortoise.contrib.pydantic import pydantic_model_creator\n\nfrom myproject.models.tortoise import Task\n\n\nTaskModelOut = pydantic_model_creator(\n    Task,\n    name=\"TaskModelOut\",\n    include=(\n        \"id\",\n        \"approved\",\n        \"code\",\n        \"created_at\"\n    ),\n)\n</code></pre>"},{"location":"example/#routerqueryset","title":"RouterQuerySet","text":""},{"location":"example/#filters","title":"Filters","text":"<p>We have a number of fields we want to let our users filter based on them. We create a RouterQuerySetFilter for this. Filter class is argument for <code>FastAPI.Depends</code> at endpoint.  </p> <p>You require to define ORM filter keyword, type of data and setup source of data (<code>Query</code>, <code>Path</code>, <code>Body</code>, etc).</p> <pre><code># querysets_filters.py\n\nimport dataclasses\nimport datetime\nfrom typing import Optional\n\nfrom fastapi import Query\n\n\n@dataclasses.dataclass\nclass RouterQuerySetFilter:\n    id__in: Optional[list[int]] = Query(None, alias='id[]')\n    approved: Optional[bool] = Query(None)\n    approved__isnull: Optional[bool] = Query(None)\n    code: Optional[str] = Query(None)\n    created_at__lte: Optional[datetime.datetime] = Query(None)\n    created_at__gte: Optional[datetime.datetime] = Query(None)\n</code></pre>"},{"location":"example/#model-queryset","title":"Model Queryset","text":"<p>Configure <code>RouterQueryset</code> properties</p> <pre><code># querysets.py\n\nfrom fastapi_querysets.mixins.filters import FilterMixin\nfrom fastapi_querysets.mixins.filters import FilterNegationMixin\nfrom fastapi_querysets.mixins.ordering import OrderingMixin\nfrom fastapi_querysets.mixins.pagination import PaginationMixin\nfrom fastapi_querysets.mixins.pagination import RouterPagination\nfrom fastapi_querysets.queryset import RouterQuerySet\n\nfrom myproject.models.tortoise import Task\nfrom myproject.querysets_filters import RouterQuerySetFilter\n\n\nclass TasksRouterQuerySet(FilterMixin, FilterNegationMixin, OrderingMixin, PaginationMixin, RouterQuerySet):\n    filter_class = RouterQuerySetFilter\n    ordering_default = \"id\"\n    ordering_fields = (\n        \"id\",\n        \"approved\",\n        \"code\",\n        \"created_at\",\n    )\n    pagination_class = RouterPagination\n    model = Task\n</code></pre>"},{"location":"example/#application","title":"Application","text":"<p>Create application, register list, list with pagination and retrieve endpoints.</p> <pre><code># app.py\n\nfrom fastapi import FastAPI\nfrom tortoise.contrib.fastapi import register_tortoise\nfrom tortoise.queryset import QuerySet\n\nfrom myproject.models.pydantic import TaskModelOut\nfrom myproject.models.tortoise import Task\nfrom myproject.querysets import TasksRouterQuerySet\n\n\napp = FastAPI()\n\n\nregister_tortoise(\n    app,\n    db_url=\"sqlite://:memory:\",\n    modules={\"models\": [\"myproject.models.tortoise\"]},\n    generate_schemas=True,\n    add_exception_handlers=True,\n)\n\n\n@app.get(\"tasks/\", response_model=list[TaskModelOut])\nasync def tasks_list_paginated(queryset: QuerySet[Task] = TasksRouterQuerySet()) -&gt; list[TaskModelOut]:\n    return await TaskModelOut.from_queryset(queryset)\n\n\n@app.get(\"tasks/paginated\", response_model=list[TaskModelOut])\nasync def tasks_list_paginated(queryset: QuerySet[Task] = TasksRouterQuerySet().paginated) -&gt; list[TaskModelOut]:\n    return await TaskModelOut.from_queryset(queryset)\n\n\n@app.get(\"tasks/{instance_id}\", response_model=list[TaskModelOut])\nasync def tasks_retrieve(task: QuerySet[Task] = TasksRouterQuerySet().instance) -&gt; list[TaskModelOut]:\n    return TaskModelOut.from_orm(task)\n</code></pre>"},{"location":"example/#requests","title":"Requests","text":""},{"location":"example/#list","title":"List","text":"<p>On request effective queryset will be filtered and ordered by query params.</p> <p>For example, user has requested endpoint with some query params</p> <pre><code>{\n    \"created_at__lte\": \"2023-01-01T00:00:00\",\n    \"approved\": false,\n    \"ordering[]\": \"created_at\",\n}\n</code></pre> <p>Request URL looks like <code>http://localhost:8000/tasks/?created_at__lte=2023-01-01T00:00:00&amp;approved=false&amp;ordering[]=created_at</code></p> <p>Effective queryset at the endpoint method will be</p> <pre><code>(\n    Task\n    .filter(created_at__lte=datetime.datetime(2023, 1, 1, 0, 0, 0), approved=False)\n    .order_by(\"created_at\")\n)\n</code></pre>"},{"location":"example/#list-paginated","title":"List paginated","text":"<p>Like not paginated endpoint at this queryset will be filtered, ordering and additional paginated.</p> <p>For example, user has requested endpoint with some query params</p> <pre><code>{\n    \"page\": 2,\n    \"per_page\": 10,\n    \"created_at__lte\": \"2023-01-01T00:00:00\",\n    \"approved\": false,\n    \"ordering[]\": \"created_at\",\n}\n</code></pre> <p>Request URL looks like  <code>http://localhost:8000/tasks/?page=2&amp;per_page=10&amp;created_at__lte=2023-01-01T00:00:00&amp;approved=false&amp;ordering[]=created_at</code></p> <p>Effective queryset at endpoint method will be</p> <pre><code>(\n    Task\n    .filter(created_at__lte=datetime.datetime(2023, 1, 1, 0, 0, 0), approved=False)\n    .order_by(\"created_at\")\n    .offset(10)\n    .limit(10)\n)\n</code></pre> <p>As well as to <code>Response</code> will be added pagination information. Pagination information always matches effective queryset</p> <pre><code>{\n    \"x-page\": \"2\",\n    \"x-pages\": \"4\",\n    \"x-per-page\": \"10\",\n    \"x-total\": \"32\"\n}\n</code></pre>"},{"location":"example/#retrieve","title":"Retrieve","text":"<p>Request URL looks like  <code>http://localhost:8000/tasks/10/</code></p> <p>Endpoint method will get <code>Task</code> with <code>id == 10</code> as argument <code>task</code>.    If <code>Task</code> with <code>id == 10</code> does not exist then endpoint return <code>Response(404)</code> </p>"},{"location":"release_notes/","title":"Release Notes","text":""},{"location":"release_notes/#011","title":"0.1.1","text":"<p>Fix - Dependencies</p> <p>Misc - Documentation</p>"},{"location":"release_notes/#010","title":"0.1.0","text":"<ul> <li>Initial release</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#support-more-orm","title":"Support more ORM","text":"<ul> <li>SQLAlchemy</li> <li>Peewee</li> </ul>"},{"location":"user_guide/excluding/","title":"FilterNegationMixin","text":"<p><code>FilterNegationMixin</code> is like <code>FilterMixin</code> but filter queryset by excluding. </p>"},{"location":"user_guide/excluding/#example","title":"Example","text":"<pre><code>import dataclasses\nimport datetime\nfrom typing import Optional\n\nfrom fastapi import Query\nfrom fastapi_querysets.mixins.filters import FilterNegationMixin\nfrom fastapi_querysets.queryset import RouterQuerySet\n\nfrom myproject.models.tortoise import Task\n\n\n@dataclasses.dataclass\nclass RouterQuerySetFilter:\n    id__in: Optional[list[int]] = Query(None, alias='id[]')\n    approved: Optional[bool] = Query(None)\n    approved__isnull: Optional[bool] = Query(None)\n    code: Optional[str] = Query(None)\n    created_at__lte: Optional[datetime.datetime] = Query(None)\n    created_at__gte: Optional[datetime.datetime] = Query(None)\n\n\nclass WorkersRouterQuerySet(FilterNegationMixin, RouterQuerySet):\n    filter_class = RouterQuerySetFilter\n    model = Task\n    pk_model = 'id'\n</code></pre>"},{"location":"user_guide/excluding/#properties","title":"Properties","text":"<p><code>filter_class</code> - <code>dataclasses.dataclass</code> class that defined possible filters with source and type annotations. Read more about filtering. <code>FilterNegationMixin</code> generate <code>exclude_class</code> automatically depends on <code>filter_class</code> by appending <code>!</code> to property name.</p>"},{"location":"user_guide/excluding/#methods","title":"Methods","text":"<p><code>get_request_queryset</code> - return filtered queryset by excluding</p> <ul> <li>request - <code>starlette.requests.Request</code></li> <li>filters - <code>dataclasses.dataclass</code> instance of <code>exclude_class</code> with defined fields by request</li> <li>queryset - <code>QuerySet</code>. Get it from parent class using mro. Return it filtered.</li> </ul> <p><code>exclude_class</code> - read only, automatically generates from FilterClass. It would be looks like below definition. </p> <pre><code>import dataclasses\nimport datetime\nfrom typing import Optional\n\nfrom fastapi import Query\n\n@dataclasses.dataclass\nclass RouterQuerySetFilterNegation:\n    id__in: Optional[list[int]] = Query(None, alias='id[]!')\n    approved: Optional[bool] = Query(None, alias='approved!')\n    approved__isnull: Optional[bool] = Query(None, alias='approved__isnull!')\n    code: Optional[str] = Query(None, alias='!')\n    created_at__lte: Optional[datetime.datetime] = Query(None, alias='created_at__lte!')\n    created_at__gte: Optional[datetime.datetime] = Query(None, alias='created_at__gte!')\n</code></pre>"},{"location":"user_guide/filtering/","title":"FilterMixin","text":"<p><code>FilterMixin</code> to restrict <code>RouterQuerySet.get_router_queryset</code> according to user sent params</p>"},{"location":"user_guide/filtering/#example","title":"Example","text":"<pre><code>import dataclasses\nimport datetime\nfrom typing import Optional\n\nfrom fastapi import Query\nfrom fastapi_querysets.mixins.filters import FilterMixin\nfrom fastapi_querysets.queryset import RouterQuerySet\n\nfrom myproject.models.tortoise import Task\n\n\n@dataclasses.dataclass\nclass RouterQuerySetFilter:\n    id__in: Optional[list[int]] = Query(None, alias='id[]')\n    approved: Optional[bool] = Query(None)\n    approved__isnull: Optional[bool] = Query(None)\n    code: Optional[str] = Query(None)\n    created_at__lte: Optional[datetime.datetime] = Query(None)\n    created_at__gte: Optional[datetime.datetime] = Query(None)\n\n\nclass WorkersRouterQuerySet(FilterMixin, RouterQuerySet):\n    filter_class = RouterQuerySetFilter\n    model = Task\n    pk_model = 'id'\n</code></pre>"},{"location":"user_guide/filtering/#properties","title":"Properties","text":"<p><code>filter_class</code> - <code>dataclasses.dataclass</code> class that defined possible filters with source and type annotations. Read more about filter class</p>"},{"location":"user_guide/filtering/#methods","title":"Methods","text":"<p><code>get_request_queryset</code> - return filtered queryset</p> <ul> <li>request - <code>starlette.requests.Request</code></li> <li>filters - <code>dataclasses.dataclass</code> instance of <code>filter_class</code> with defined fields by request</li> <li>queryset - <code>QuerySet</code>. Get it from parent class using mro. Return it filtered.</li> </ul>"},{"location":"user_guide/filtering/#filterclass","title":"FilterClass","text":"<p><code>dataclasses.dataclass</code> class. Property name is filter keyword. Typing use for <code>FastApi</code> data validation. Every property must have valid <code>FastAPI</code> source like <code>Query</code>, <code>Body</code>, <code>Path</code>, etc.</p>"},{"location":"user_guide/filtering/#example_1","title":"Example","text":"<pre><code>import dataclasses\nimport datetime\nfrom typing import Optional\n\nfrom fastapi import Query\n\n@dataclasses.dataclass\nclass RouterQuerySetFilter:\n    id__in: Optional[list[int]] = Query(None, alias='id[]')\n    approved: Optional[bool] = Query(None)\n    approved__isnull: Optional[bool] = Query(None)\n    code: Optional[str] = Query(None)\n    created_at__lte: Optional[datetime.datetime] = Query(None)\n    created_at__gte: Optional[datetime.datetime] = Query(None)\n</code></pre>"},{"location":"user_guide/ordering/","title":"OrderingMixin","text":"<p><code>OrderingMixin</code> for ordering queryset. To ordering queryset user should define <code>ordering[]</code> query params and values of list must be in <code>ordering_fields</code>. For descending ordering just prepend <code>-</code> to field name like <code>?ordering[]=-id</code>.</p>"},{"location":"user_guide/ordering/#example","title":"Example","text":"<pre><code>from fastapi_querysets.mixins.ordering import OrderingMixin\nfrom fastapi_querysets.queryset import RouterQuerySet\n\nfrom myproject.models.tortoise import Task\n\nclass WorkersRouterQuerySet(OrderingMixin, RouterQuerySet):\n    model = Task\n    ordering_default = 'id'\n    ordering_fields = (\n        \"id\",\n        \"approved\",\n        \"code\",\n        \"created_at\",\n    )\n    pk_model = 'id'\n</code></pre>"},{"location":"user_guide/ordering/#properties","title":"Properties","text":"<p><code>ordering_default</code> - <code>str</code> or <code>list[str]</code>. That ordering will apply if user not define <code>ordering[]</code> param.</p> <p><code>ordering_fields</code> - <code>Sequence[str]</code>. List of allowed fields to order queryset. You can use related fields.</p>"},{"location":"user_guide/pagination/","title":"PaginationMixin","text":"<p><code>PaginationMixin</code> to limit queryset. Endpoint will have <code>page</code> and <code>per_page</code> query params for pagination. Query params <code>page</code> and <code>per_page</code> must be greater than 1.</p> <p>Mixing additionally add pagination information to response.</p>"},{"location":"user_guide/pagination/#example","title":"Example","text":"<pre><code>from fastapi_querysets.mixins.pagination import PaginationMixin\nfrom fastapi_querysets.mixins.pagination import RouterPagination\nfrom fastapi_querysets.queryset import RouterQuerySet\n\nfrom myproject.models.tortoise import Task\n\nclass WorkersRouterQuerySet(PaginationMixin, RouterQuerySet):\n    model = Task\n    pagination_class = RouterPagination\n    pk_model = 'id'\n</code></pre>"},{"location":"user_guide/pagination/#properties","title":"Properties","text":"<p><code>pagination_class</code> - <code>Type[RouterPagination]</code>, you can define class one time and reuse it for all endpoints to them have same pagination settings. </p> <p><code>ordering_fields</code> - <code>Sequence[str]</code>. List of allowed fields to order queryset. You can use related fields.</p>"},{"location":"user_guide/pagination/#pagination-class","title":"Pagination class","text":"<p>Define pagination class require your project and use it instead <code>RouterPagination</code> as <code>pagination_class</code></p>"},{"location":"user_guide/pagination/#example_1","title":"Example","text":"<pre><code>from fastapi_querysets.mixins.pagination import RouterPagination\n\nclass ApiRouterPagination(RouterPagination):\n    per_page_max: int = 25\n    per_page: int = 50\n</code></pre>"},{"location":"user_guide/pagination/#properties_1","title":"Properties","text":"<ul> <li><code>per_page_max</code> - <code>int</code>, limit max items in response. <code>per_page</code> will be reduced to <code>per_page_max</code> if user send <code>per_page</code> greater than <code>per_page_max</code>.</li> <li><code>per_page</code> - <code>int</code>, that value will be used if user not send <code>per_page</code> query params</li> </ul>"},{"location":"user_guide/router_query_set/","title":"RouterQuerySet","text":"<p><code>RouterQuerySet</code> is base class for endpoints queryset. It has two method (<code>get_request_queryset</code> and <code>get_request_instance</code>) used for endpoints.</p>"},{"location":"user_guide/router_query_set/#example","title":"Example","text":"<pre><code>from fastapi_querysets.queryset import RouterQuerySet\n\nfrom myproject.models.tortoise import Task\n\n\nclass WorkersRouterQuerySet(RouterQuerySet):\n    model = Task\n    pk_model = 'id'\n</code></pre>"},{"location":"user_guide/router_query_set/#properties","title":"Properties","text":"<p><code>model</code> - you have to define ORM model for <code>RouterQuerySet</code>. <code>RouterQuerySet</code> will automatically use it for defining endpoint queryset and getting instance.</p> <p><code>pk_model</code> - <code>model</code> primary key. Default is <code>id</code></p> <p><code>instance</code> - read only, use this property to get instance of <code>model</code> to your endpoint.</p>"},{"location":"user_guide/router_query_set/#methods","title":"Methods","text":"<p><code>get_queryset</code> - base queryset. Generates form <code>model</code>. You can redefine it to prefetching some data, constant filtering, aggregation or annotating.</p> <p><code>get_request_queryset</code> - method will be called to get endpoint effective queryset.</p> <ul> <li><code>queryset</code> - effective queryset. Value is result of method <code>get_request_queryset</code>. Basic class return it as result of method.</li> </ul> <p><code>get_request_instance</code> - method will be called to get instance of <code>model</code>. If instance does not exist will return <code>Response(404)</code>.</p> <ul> <li><code>queryset</code> - base queryset to get instance by primary key. Base class will get it as result of method <code>get_request_queryset</code>.</li> <li><code>pk</code> - source of primary key value. Primary key column defines as class property (<code>pk_model</code>).</li> </ul>"}]}